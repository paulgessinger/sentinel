# Container image
image:
  repository: ghcr.io/paulgessinger/sentinel
  tag: "latest"
  pullPolicy: IfNotPresent

# GitHub App credentials (required).
# Either set these directly (they will be stored in a Secret) or reference an
# existing Secret via existingSecret.
github:
  appId: ""
  webhookSecret: ""
  # PEM-encoded RSA private key. In a values file use a block scalar:
  #   privateKey: |
  #     -----BEGIN RSA PRIVATE KEY-----
  #     ...
  #     -----END RSA PRIVATE KEY-----
  privateKey: ""
  # Name of a pre-existing Secret containing the credentials.
  # When set, the github.appId / webhookSecret / privateKey fields above are ignored.
  existingSecret: ""
  existingSecretKeys:
    appId: GITHUB_APP_ID
    webhookSecret: GITHUB_WEBHOOK_SECRET
    privateKey: GITHUB_PRIVATE_KEY

# Web server (Sanic/uvicorn) deployment
web:
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

# Persistent storage for the diskcache directory and SQLite webhook DB.
persistence:
  enabled: true
  storageClass: ""        # leave empty to use the cluster default
  accessMode: ReadWriteMany
  size: 5Gi
  # Optionally bind to an existing PVC instead of creating one.
  existingClaim: ""

# Application configuration (non-sensitive environment variables)
config:
  logLevel: WARNING
  prTimeout: "10"
  workerSleep: "1"
  accessTokenTtl: "300"
  prsTtl: "60"
  dryRun: "false"
  checkRunDebounceWindow: "3600"
  checkRunNameFilter: ""
  repoAllowlist: ""
  processStartPause: "5"

  # Webhook SQLite persistence
  webhookDbEnabled: "true"
  webhookDbRetentionDays: "30"
  webhookDbEvents: "check_run,check_suite,workflow_run,status,pull_request"
  webhookDispatchEnabled: "false"

  # Webhook projection pruning
  webhookProjectionPruneEnabled: "true"
  webhookProjectionCompletedRetentionSeconds: "604800"   # 7 days
  webhookProjectionActiveRetentionSeconds: "2592000"      # 30 days

  # Webhook self-filter
  webhookFilterSelfAppId: "true"
  webhookFilterAppIds: ""

  # Projection-driven evaluation
  projectionEvalEnabled: "false"
  projectionPublishEnabled: "false"
  projectionDebounceSeconds: "2"
  projectionPullRequestSynchronizeDelaySeconds: "15"
  projectionCheckRunName: "merge-sentinel"
  projectionConfigCacheSeconds: "300"
  projectionPrFilesCacheSeconds: "86400"
  projectionPathRuleFallbackEnabled: "true"

# Optional Telegram notifications
telegram:
  enabled: false
  token: ""
  chatId: ""
  # Reference an existing Secret instead of creating one.
  existingSecret: ""
  existingSecretKeys:
    token: TELEGRAM_TOKEN
    chatId: TELEGRAM_CHAT_ID

# Service
service:
  type: ClusterIP
  port: 8080

# OpenShift Route
route:
  enabled: true
  host: ""   # auto-generated by OpenShift when empty
  tls:
    enabled: true
    termination: edge
    insecureEdgeTerminationPolicy: Redirect

# Service account
serviceAccount:
  create: true
  name: ""
  annotations: {}

# Pod-level annotations. The defaults enable Prometheus scraping.
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics"

# Optional image pull secrets (e.g. for private registries)
imagePullSecrets: []

nodeSelector: {}
tolerations: []
affinity: {}

# Security context for all containers.
# The Dockerfile already creates a non-root "sentinel" user (UID 1000),
# which is compatible with OpenShift's restricted SCC.
podSecurityContext:
  fsGroup: 1000

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false   # diskcache writes to the data volume
  capabilities:
    drop:
      - ALL
